/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

#define GPIOBEN (1U<<1)
#define I2C1EN (1U<<21)
#define I2C_100KHZ 80
#define SD_MODE_MAX_RISE_TIME 17
#define CR1_PE (1U<<0)

// ASSIGN SYMBLOIC NAME TO REQUIRED REGISTERS
#define SR2_BUSY (1U<<1)
#define SR1_SB (1U<<0)
#define SR1_ADDR (1U<<1)
#define SR1_TXE (1U<<7)
#define SR1_RXNE (1U<<6)
#define SR1_BTF (1U<<2)

#define CR1_START (1U<<8)
#define CR1_PE (1U<<0)
#define CR1_ACK (1U<10)
#define CR1_STOP (1U<<9)


//PB6 - SCL
//PB7 - SDA

void I2C1_Init(void);
void I2C1_ByteRead(char saddr, char maddr, char* data);
void I2C1_BurstRead(char saddr, char maddr,int n, char* data);
void I2C1_BurstWrite(char saddr, char maddr,int n, char* data);

int main(void)
{

}


void I2C1_Init(void){
	//Enable the clock access to PORT B-I2C1
	RCC->AHB1ENR |= GPIOBEN;

	//SET PB6 AND PB7 TO Alternate function
	GPIOB->MODER &=~(1U<<16);
	GPIOB->MODER |=~(1U<<17);

	GPIOB->MODER &=~(1U<<18);
	GPIOB->MODER |=~(1U<<19);

	//SET OUTTYPE AS OPEN DRAIN
	GPIOB->OTYPER |= (1U<<8);
	GPIOB->OTYPER |= (1U<<9);

	//SET PILLUP FOR BOTH
	GPIOB->PUPDR |= (1U<<16);
	GPIOB->PUPDR &=~ (1U<<17);

    //SET THE ALTERNATE FUNCTION TYPE FOR I2C
	GPIOB->AFR[1] &=~(1U<<0);
	GPIOB->AFR[1] &=~(1U<<1);
	GPIOB->AFR[1] |=~(1U<<2);
	GPIOB->AFR[1] &=~(1U<<3);

	GPIOB->AFR[1] &=~(1U<<4);
	GPIOB->AFR[1] &=~(1U<<5);
	GPIOB->AFR[1] |=~(1U<<6);
	GPIOB->AFR[1] &=~(1U<<7);

	//TO ENABLE PERIPHERAL BUS
	RCC->AHB1ENR |= I2C1EN;
	//ENTER TO RESET MODE
	I2C1->CR1 |= (1U<<15);
	//COME OUR OF THE RESET MODE
	I2C1->CR1 |=~ (1U<<15);
	//SET THE PERIPHERAL CLOCK FREQUENTX
	I2C1->CR2 = (1U<<4);  //FREQUEANCY TO 16 MHZ

	I2C1->CCR = I2C_100KHZ;
	I2C1->TRISE = SD_MODE_MAX_RISE_TIME;

	I2C1->CR1 |= CR1_PE;
}
//saddr-slave address
//maddr -memory addres
//dataa pointer

void I2C1_ByteRead(char saddr,char maddr,char* data)
{
  volatile int tmp;
	//Wait until bus is not busy
	while(I2C1->SR2 & (SR2_BUSY)){}
	//Generate Start Condition
	I2C1->CR1 |=CR1_START;
	//Wait until the start flag is set
	while(!(I2C1->SR1 & (SR1_SB))){}

	//Transmit Slave address +write

	I2C1->DR=saddr<<1;

	//Wait until TXE addr flag is set
	while(!(I2C1->SR1 & (SR1_ADDR))){}

	//Clear addr flag
	tmp=I2C1->SR2;

	//Send memory address
	I2C1->DR=maddr;

	//Wait until TXE transmitter is empty
	while(!(I2C1->SR1 & (SR1_TXE))){}

	//Generate restart
	I2C1->CR1 |=CR1_START;

	//Wait until start flag is set
	while(!(I2C1->SR1 & (SR1_SB))){}


	//Transmit slave address+read
	I2C1->DR=saddr<<1 |1;

	//Wait until the address flag is set
	while(!(I2C1->SR1 & (SR1_ADDR))){}

	//Disable Acknoweledgemnt
	I2C1->CR1 &= ~CR1_ACK;
	//cLEAR THE ADDR FLAG
	tmp=I2C1->SR2;

	//Generate stop after data received
	I2C1->CR1 |= CR1_STOP;


	//wait until RXNE flag is set
	while(!(I2C1->SR1 & (SR1_RXNE))){}

	//Read data from Data register

    *data++ =I2C1->DR;
}

void I2C1_BurstRead(char saddr,char maddr,int n,char* data)
{

	volatile int tmp;
		//Wait untill bus is not busy
		while(I2C1->SR2 & (SR2_BUSY)){}

		//Generate Start Condition
		I2C1->CR1 |=CR1_START;

		//Wait until the start flag is set
		while(!(I2C1->SR1 & (SR1_SB))){}

		//Transmit Slave address +write

		I2C1->DR=saddr<<1;

		//Wait until TXE addr flag is set
		while(!(I2C1->SR1 & (SR1_ADDR))){}

		//Clear addr flag
		tmp=I2C1->SR2;



		//Wait until TXE transmitter is empty
		while(!(I2C1->SR1 & (SR1_TXE))){}
		//Send memory address
				I2C1->DR=maddr;
	    while(!(I2C1->SR1 & (SR1_TXE))){}

		//Generate restart
		I2C1->CR1 |=CR1_START;

		//Wait until start flag is set
		while(!(I2C1->SR1 & (SR1_SB))){}


		//Transmit slave address+read
		I2C1->DR=saddr<<1 |1;

		//Wait until the address flag is set
		while(!(I2C1->SR1 & (SR1_ADDR))){}

		//cLEAR THE ADDR FLAG
		tmp=I2C1->SR2;

		//enable acknoweledgement
		I2C1->CR1|=CR1_ACK;
		while(n> 0U)
		{
			if (n==1U)
			{
				I2C1->CR1 &=~CR1_ACK;
				//Generate stop after data received
					I2C1->CR1 |= CR1_STOP;


					//wait till  RXNE flag is set
					while(!(I2C1->SR1 & (SR1_RXNE))){}

					//Read data from Data register

				    *data++ =I2C1->DR;

                 break;

			}
			else
			{while(!(I2C1->SR1 & (SR1_RXNE))){}

			//Read data from Data register

		    (*data++) =I2C1->DR;
		    n--;

			}
		}

}

void I2C1_BurstWrite(char saddr,char maddr,int n,char* data)
{
	volatile int tmp;
			//Wait until bus is not busy
			while(I2C1->SR2 & (SR2_BUSY)){}

			//Generate Start Condition
			I2C1->CR1 |=CR1_START;

			//Wait until the start flag is set
			while(!(I2C1->SR1 & (SR1_SB))){}

			//Transmit Slave address +write
			I2C1->DR=saddr<<1;

			//Wait until TXE addr flag is set
			while(!(I2C1->SR1 & (SR1_ADDR))){}

			//Clear addr flag
			tmp=I2C1->SR2;


			//Wait until TXE transmitter is empty
			while(!(I2C1->SR1 & (SR1_TXE))){}

			//Send memory address
			I2C1->DR=maddr;

			for(int i=0; i<n ;i++)
			{
				//Wait until TXE transmitter is empty
						while(!(I2C1->SR1 & (SR1_TXE))){}
						I2C1->DR =*data++;
			}

			while(!(I2C1->SR1 & (SR1_BTF))){}
			//Generate stop after data received
								I2C1->CR1 |= CR1_STOP;
}
