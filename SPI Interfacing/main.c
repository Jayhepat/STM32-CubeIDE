/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

//,ISO -> PA6
//MOSI ->PA7
//SCLK -> PA5
//AF05
#define GPIOAEN (1U<<0)
#define SPI1EN  (1U<<12)

//CS -> PA9
//Symbolic names for ADXL345 Accelerometer
#define DEVID_R (0X00)    // FROM DATA SHEET, TYPR R
#define DATA_FORMAT_R (0X31)
#define POWER_CTL_R (0X2D)
#define DATA_START_ADDR (0X32)
#define DEVICE_ADDR (0X53)
#define FOUR_G (0X01)
#define RESET (0X00)
#define SET_MEASURE_B (0X08)

//Symbolic names for SPI Peripherals
#define SR_TXE (1U<<1)
#define SR_RXNE (1U<<0)
#define SR_BUSY (1U<<7)
#define MULTI_BYTE_EN 0X40
#define READ_OPERATION 0X80



void spi_config(void);
void cs_enable(void);
void cs_disable(void);
void spi_gpio_init(void);
void spi_receive(uint8_t *data, uint32_t size);
void spi_transmit(uint8_t *data, uint32_t size);

void adxl_Read_Values(uint8_t reg);
void adxl_Write(uint8_t reg, char value);
void adxl_read_address(uint8_t reg);

char data;
uint8_t data_rec[6];
int16_t x,y,z;
float xg,yg,zg;

int main(void){
	adxl_init();
	while(1){
		adxl_read(DATA_START_ADDR, data_rec);
		x = ((data_rec[1]<<8) | data_rec[0]);
		y = ((data_rec[3]<<8) | data_rec[2]);
		z = ((data_rec[5]<<8) | data_rec[4]);
		xg = (x*0.0078);
		yg = (y*0.0078);
		zg = (z*0.0078);

	}
}

void adxl_init(void){

	spi_gpio_init();
	spi_config();

	adxl_Write(DATA_FORMAT_R, FOUR_G);
	//RESET ALL THE BITS
	adxl_Write(POWER_CTL_R, FOUR_G);
	adxl_Write(POWER_CTL_R, SET_MEASURE_B);  //Measure the data through power control
	                                         //data is stored in 4-bits


}
void adxl_Read_Values(uint8_t reg){
 }

void adxl_Write(uint8_t address , char value){
	uint8_t data[2];
	//enable multi_byte
	data[0] = address|MULTI_BYTE_EN;;
	data[1] = value;
	cs_enable();
	spi_transmit(data, 2);
	cs_disable();


 }

void adxl_read(uint8_t address, uint8_t *rxdata){
	//SET READ OPERATION
	address |= READ_OPERATION;
	//ENABLE MULTI_BYTE
	address |= MULTI_BYTE_EN;
	cs_enable();
	spi_transmit(&address, 1);
	spi_receive(rxdata, 6);
	cs_disable();
 }

void spi_gpio_init(void){
	RCC->AHB1ENR |= GPIOAEN;

	//SET PA5 FOR SPI->ALTERNATE
	GPIOA->MODER &= ~(1U<<10); //SET 0
	GPIOA->MODER |= (1U<<11); //SET 1

	//SET PA6 FOR SPI->ALTERNATE
		GPIOA->MODER &= ~(1U<<12); //SET 0
		GPIOA->MODER |= (1U<<13); //SET 1

		//SET PA9 FOR SLAVE SELECT ->OUTPUT
		GPIOA->MODER |= (1U<<18); //SET 0
		GPIOA->MODER &= ~(1U<<19); //SET 1

		//SET PA5
		GPIOA->AFR[0] |= (1U<<20);   //SET 1
		GPIOA->AFR[0] &= ~(1U<<21); //SET 0
		GPIOA->AFR[0] |= (1U<<22);  //SET 1
		GPIOA->AFR[0] &= ~(1U<<23); //SET 0

		//SET PA6
		GPIOA->AFR[0] |= (1U<<24);   //SET 1
		GPIOA->AFR[0] &= ~(1U<<25); //SET 0
		GPIOA->AFR[0] |= (1U<<26);  //SET 1
		GPIOA->AFR[0] &= ~(1U<<27); //SET 0

		//SET PA7
		GPIOA->AFR[0] |= (1U<<28);   //SET 1
		GPIOA->AFR[0] &= ~(1U<<29); //SET 0
		GPIOA->AFR[0] |= (1U<<30);  //SET 1
		GPIOA->AFR[0] &= ~(1U<<31); //SET 0
}

void spi_config(void){
	//Enable CLK access for SPI
	RCC->APB2ENR |= SPI1EN;

	//SET CLOCK FPCLK/4
	SPI1->CR1 |= (1U<<3);
	SPI1-> CR1 &= ~(1U<<4);
	SPI1->CR1 &= ~(1U<<5);

	//SET CPOL TO 1    CPHA TO 1
	SPI1->CR1 |= (1U<<0);
	SPI1->CR1 |= (1U<<1);

	//ENABLE FULL DUPLEX
	SPI1->CR1 |= (1U<<10);

	//SET MSB FIRST
	SPI1->CR1 |= (1U<<7);

	SPI1->CR1 |= (1U<<2);//SET AS MASTER

	//SET MSB FIRST
	SPI1->CR1 |= (1U<<7);

	//TO SET 8-BIT DATA MODE
	SPI1->CR1 |= (1U<<11);

	//SELECT SOFTWARE SLAVE MANAAGEMENT
	SPI1->CR1 |= (1U<<8);
	SPI1->CR1 |= (1U<<9);

	//SPI ENBLE
	SPI1->CR1 |= (1U<<6);

}

//FUNCTION FOR SPI TRANSMIT
void spi_transmit(uint8_t *data, uint32_t size){
	uint32_t i=0;
	uint8_t temp;
	while(i<size){
		while(~(SPI1->SR * (SR_TXE))){} //WAIT UNTIL TXE IS SET

		//WRIYTE DATA TO THE REGISTER
		SPI1->DR = data[i];
		i++;
	}
	while(~(SPI1->SR * (SR_TXE))){} //WAIT UNTIL TXE IS SET
	while(~(SPI1->SR * (SR_BUSY))){} //WAIT UNTIL BUSY IS SET

	temp=SPI1->DR;
	temp=SPI1->SR;
}

//FUNCTION FOR SPI RECEIVE
void spi_receive(uint8_t *data, uint32_t size){
	while(size){
		SPI1->DR = 0;

		while(!(SPI1->SR * (SR_RXNE))){}
		*data++ = (SPI1->DR);
		size--;
	}
}

void cs_enable(void){
	GPIOA->ODR &= ~(1U<<9);
}

void cs_disable(void){
	GPIOA->ODR |= (1U<<9);
}
